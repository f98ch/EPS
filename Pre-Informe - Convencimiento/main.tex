% {{{ Paquetes, comandos etc
%%
%%	AVISO IMPORTANTE
%%	Formato optimizado para el sistema operativo GNU/Linux 64 bits
%%	usar TexLive 2016 (o superior), http://www.ctan.org/tex-archive/systems/texlive/Images/
%%	usar TeXstudio 2.11, http://texstudio.sourceforge.net/

\documentclass[letterpaper,12pt]{thesisECFM}
\usepackage{macros}

%%	NO OLVIDE INCLUIR FUENTE DE LAS TABLAS Y FIGURAS

% Descomentar para anular recuadros en los hiperenlaces dentro del pdf
\hypersetup{pdfborder={0 0 0}}

% Teoremas ---------------------------------------------------------
% estos ambientes son para teoremas, lemas, corolarios, otros
% si no los utiliza los puede obviar en su trabajo de graduación
\theoremstyle{plain}
\newtheorem{thm}{Teorema}[section]
\newtheorem{cor}{Corolario}[chapter]
\newtheorem{lem}{Lema}[chapter]
\newtheorem{prp}{Proposición}[chapter]

\theoremstyle{definition}
\newtheorem{exa}{Ejemplo}[chapter]
\newtheorem{defn}{Definición}[chapter]
\newtheorem{axm}{Axioma}[chapter]
\usepackage[draft,inline,nomargin]{fixme} \fxsetup{theme=color}
\FXRegisterAuthor{cp}{acp}{\color{blue}CP}
\FXRegisterAuthor{fel}{afel}{\color{purple}F}

\theoremstyle{remark}
\newtheorem{rem}{Nota}[chapter]

% <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
% <<<<<<<<<<<<<<                                             >>>>>>>>>>>>>>>>>>
%                 Inicio preámbulo de José Alfredo de León
% <<<<<<<<<<<<<<                                             >>>>>>>>>>>>>>>>>>
% <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



%\usepackage{lscape}		%% para poner tablas en orientación landscape
\usepackage{array}		%% para modificar cosas de entorno 'tabular'
\newcolumntype{P}[1]{>{\centering\arraybackslash}m{#1}} %para que en las tablas quede centrado verticalmente el texto


%% símbolos de mate y física --------------------------------------------------
\usepackage{amssymb}	
\usepackage{amsbsy}
\usepackage{physics}
%% ----------------------------------------------------------------------------


\usepackage{longtable}	%% tablas en más de una página
\usepackage{float}		%% para poder usar H, h! en entornos table y figure, por ej.

%% para poner subfiguras
\usepackage{caption} 
\usepackage{subcaption}

\usepackage{lipsum} % para poner texto equis
\usepackage{rotating} % para poner tablas rotadas

%%% ----------------------------------------------------------------------------
%% \usepackage[inline]{showlabels}		%% para mostrar labels en el PDF
		
			
\usepackage{graphicx}			%% para colocar imágenes
\graphicspath{ {./img/} }		%% ruta a carpeta con imágenes


%% Para enumerar las líneas del PDF -------------------------------------------
\usepackage[]{lineno} %\linenumbers
\linenumbers
\setlength\linenumbersep{3pt}
%% para que funcione mejor la numeración {{{
%% https://tex.stackexchange.com/questions/43648/why-doesnt-lineno-number-a-paragraph-when-it-is-followed-by-an-align-equation
%\newcommand*\patchAmsMathEnvironmentForLineno[1]{%
%  \expandafter\let\csname old#1\expandafter\endcsname\csname #1\endcsname
%  \expandafter\let\csname oldend#1\expandafter\endcsname\csname end#1\endcsname
%  \renewenvironment{#1}%
%     {\linenomath\csname old#1\endcsname}%
%     {\csname oldend#1\endcsname\endlinenomath}}% 
%\newcommand*\patchBothAmsMathEnvironmentsForLineno[1]{%
%  \patchAmsMathEnvironmentForLineno{#1}%
%  \patchAmsMathEnvironmentForLineno{#1*}}%
%\AtBeginDocument{%
%\patchBothAmsMathEnvironmentsForLineno{equation}%
%\patchBothAmsMathEnvironmentsForLineno{align}%
%\patchBothAmsMathEnvironmentsForLineno{flalign}%
%\patchBothAmsMathEnvironmentsForLineno{alignat}%
%\patchBothAmsMathEnvironmentsForLineno{gather}%
%\patchBothAmsMathEnvironmentsForLineno{multline}%
%}
%% }}}	
%% ----------------------------------------------------------------------------


%%%%%%%%%%%%   Inicio definición de comandos   %%%%%%%%%%%%%%%%
\newcommand{\fref}[1]{fig.~\ref{#1}}   \newcommand{\tref}[1]{tabla~\ref{#1}}     
\newcommand{\Fref}[1]{Fig.~\ref{#1}}  \newcommand{\Tref}[1]{Tabla~\ref{#1}}
\newcommand{\Cref}[1]{Cuadro~\ref{#1}}
\newcommand{\psii}{\psi_i}
\newcommand{\Pk}[1]{\ket{\psi_{#1} }}
\newcommand{\Pb}[1]{\bra{\psi_{#1} }}
\newcommand{\pk}{\ket{\psi}}
\newcommand{\M}{\mathcal{M}^{(N)}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\Erho}{\mathcal{E}(\rho)}
\newcommand{\1}{\mathbb{1}}
\newcommand{\ten}{\otimes}
\newcommand{\h}[1]{\colorbox{yellow}{#1}}
\newcommand{\hi}{\mathcal{H}}
\newcommand{\txt}[1]{\text{#1}}
\newcommand{\here}{\h{\hspace{15cm}} }
\newcommand{\rhoi}{\dyad{\psii}{\psii}}
\newcommand{\ind}[2]{{{}^{#1}_{#2}}}
\newcommand{\rc}[1]{r_{#1}}
\newcommand{\pauli}[2]{\sigma_{#1}\otimes\sigma_{#2}}
\newcommand{\esqueleto}[1]{\textcolor{JAsColor}
{\noindent\textbf{Esqueleto:} #1}}
\newcommand{\ot}{\otimes}
\newcommand{\m}{\textcolor{JAsColor}{|}}
\newcommand{\taus}{\tau_{j_1,\ldots ,j_n}}
\newcommand{\tauijk}[3]{\boldmath{$\tau_{#1#2#3}$}}
\newcommand{\tauij}[2]{\boldmath{$\tau_{#1#2}$}}
\newcommand{\ep}{\textbf{Fuente:} elaboración propia.}
\newcommand{\subind}[2]{{}_{#1}^{#2}}
\newcommand{\ruskaiMap}{canal diagonal de Pauli constante sobre los ejes}
\newcommand{\ruskai}{canales diagonales de Pauli constantes sobre los ejes}
%%%%%%%%%%%   Fin definición de comandos   %%%%%%%%%%%%%%%%%%


% Cosas que no sé porqué tengo ------------------------------------------------
\usepackage{natbib}
\usepackage{ctable} 
\usepackage{bbold}
\usepackage{fancybox}	
\usepackage{colortbl}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}


% <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
% <<<<<<<<<<<<<<                                             >>>>>>>>>>>>>>>>>>
%                   Fin preámbulo de José Alfredo de León
% <<<<<<<<<<<<<<                                             >>>>>>>>>>>>>>>>>>
% <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



% Cuerpo de la tesis -----------------------------------------------

% Preámbulo
% }}}
\begin{document}

% Datos generales del trabajo de graduación, tabla de contenidos etc {{{
\datosThesis%
{1}%						% física 1; matemática 2
{Implementación de canales cuánticos \\ de un qubit usando VQA}%		% Título del trabajo de graduación
{Felipe Antonio Ixcamparic Choy}%			% autor
{M.Sc. Juan Diego Chang\\y Dr. Carlos Francisco Pineda Zorrilla}%			% asesor
{agosto de 2024}		% mes y año de la orden de impresión
{2}							% femenino 1; masculino 2

\tableofcontents    % Índice general vinculado

% Inicio del contenido principal
\mainmatter
% }}}
\chapter*{OBJETIVOS} % {{{
\section*{General} 
\cpnote{Por favor consistencia con la capitalizacion de ``Algoritmos Variacionales''.} \felnote{Corregido. Todas las instancias vienen con inicio mayúscula.}
Estudiar y desarrollar Algoritmos Variacionales Cuánticos para la implementación de canales cuánticos de un  qubit en computadoras cuánticas.

\section*{Específicos}
\begin{itemize}
    \item Estudiar la teoría y uso de computadoras cuánticas.
    \item Comprender las definiciones fundamentales de la teoría de sistemas cuánticos abiertos y canales cuánticos.
    \item Investigar el uso de los Algoritmos Variacionales Cuánticos en la resolución de problemas de información cuántica.
    \item Implementar canales cuánticos de un qubit en computadoras cuánticas y analizar su comportamiento.
\end{itemize}
% }}}
\chapter*{INTRODUCCIÓN} % {{{
El estudio de la dinámica de sistemas cuánticos abiertos es fundamental para el avance de la computación e información cuántica. Los canales cuánticos describen la evolución de estados cuánticos en  interacción con su entorno, y son clave para el entendimiento de este tipo de sistemas.

En este trabajo, nos enfocamos en la aplicación de Algoritmos Variacionales Cuánticos (VQA) para la inicialización y optimización de canales cuánticos en plataformas de computación cuántica. Los VQA, a través de su enfoque híbrido que combina computación cuántica y optimización clásica, nos ofrecen una técnica óptima para ajustar los parámetros que gobiernan los canales cuánticos, permitiendo una mayor precisión y control en el procesamiento cuántico.

% }}}
\chapter{FUNDAMENTOS TEÓRICOS} \label{cap:fundamentos:teoricos}% {{{
\section{Introducción}

\section{Matriz Densidad}
*Sección heredada de informe de prácticas

Un sistema cuántico se describe mediante un vector complejo $\ket{\psi}$, conocido como estado cuántico. Un estado cuántico puro se representa como:
$
\ket{\psi} = \sum_{i=1}^{d} c_i \ket{i},
$
donde $c_i$ son coeficientes complejos y $\{\ket{i}\}$ es una base ortonormal. Los coeficientes deben cumplir con la condición de normalización:
$
\braket{\psi}{\psi}=1.
$ \par 
Los estados puros pueden representarse mediante la matriz densidad:$\rho = \ketbra{\psi}.$. \par   
 
Un estado mixto es un ensamble estadístico de estados puros $\{\ket{\psi_i}\}$ con probabilidades $\{p_i\}$. La matriz densidad para estados mixtos es:$\rho = \sum_{i=1}^{n} p_i \ketbra{\psi_i}.$ \par 

La matriz densidad $\rho$ tiene tres propiedades principales: Hermiticidad , traza unitaria y no negatividad. \par

La pureza de un estado cuántico mide qué tan mixto es el estado. Se define como $\text{Pureza} = tr(\rho^2).$ \par

La traza parcial se usa para obtener la matriz densidad reducida de un subsistema en estados compuestos. Por ejemplo, si tenemos un sistema compuesto por dos subsistemas $A$ y $B$, la matriz densidad reducida del subsistema $A$ se obtiene trazando sobre el subsistema $B$:
$\rho_A = tr_B(\rho_{AB}).$ \par

La purificación es un proceso para representar un estado mixto como un estado puro en un espacio de Hilbert ampliado. Esto es útil en computadoras cuánticas para iniciar estados mixtos. \par 



\section{Canales Cuánticos y su representación}
La dinámica de un sistema cuántico abierto se describe mediante la interacción de un sistema principal y un entorno, formando un sistema cuántico cerrado \cite{nielsen_chuang_2011}. Esta interacción se da por una transformación unitaria $U$, resultando en el estado final del sistema principal $\mathcal{E}$. \par 

Los operadores cuánticos pueden representarse mediante la \textit{representación de Kraus}, donde los operadores ${E_k}$ satisfacen la \textit{relación de completitud}. La \textit{matriz de Choi} es otra representación útil para caracterizar los canales cuánticos, definida como $\Lambda_{\mathcal{E}} = (I \otimes \mathcal{E})(|\Omega\rangle\langle\Omega|)$. \par 

La matriz de Choi tiene varias propiedades: es Hermítica, puede expresarse en términos de los operadores de Kraus, es positivo semidefinido y su traza parcial es la identidad si preserva la traza. Además, la matriz de Choi de un operador CPTP es única, mientras que la representación de Kraus no lo es. \par 

El Canal Despolarizante (DP) es un ejemplo de canal cuántico que introduce ruido aleatorio en un sistema. Su matriz de Choi refleja cómo el canal mezcla el estado original con la matriz identidad, reduciendo la pureza del estado. \par 

En los siguientes capítulos se detallará el proceso para implementar la matriz de Choi y reconstruirla en sistemas cuánticos. \par 
\section{Circuitos Cuánticos}
*Heredado de informe de prácticas 

Previo a hablar sobre compuertas y circuitos cuánticos, introducimos la Esfera de Bloch para representar geométricamente al qubit. Esta esfera nos permite visualizar los cambios del estado de un qubit bajo transformaciones unitarias $U$. \par 

Las computadoras cuánticas tienen compuertas cuánticas, operadores unitarios reversibles $U$ que actúan linealmente sobre qubits en superposición. Las compuertas $X$, $Y$ y $Z$ representan las matrices de Pauli $\sigma_x$, $\sigma_y$ y $\sigma_z$ respectivamente. \par 

Un circuito cuántico es una rutina computacional con operadores que actúan sobre qubits. Los circuitos se conforman por cables, compuertas y mediciones. \par 

Para este trabajo, utilizamos la plataforma \textit{IBM Quantum Experience}, que nos da acceso a computadoras cuánticas para ejecutar circuitos cuánticos válidos. \par  
% }}}
\chapter{ALGORITMOS VARIACIONALES CUÁNTICOS (VQA)} % {{{
\section{Introducción}
\section{Descripción de los VQA}
Los Algoritmos Variacionales Cuánticos son una clase de algoritmos que combinan computación cuántica y clásica para resolver problemas de optimización. \par 

El \textit{ansatz} es una suposición inicial o una forma parametrizada del estado cuántico que se va a optimizar. La calidad del \textit{ansatz} afecta directamente la eficiencia del VQA . \par 

La función de costo $C(\theta)$ mide la calidad de la solución propuesta por el algoritmo cuántico. Esta función es evaluada en un circuito cuántico y luego optimizada clásicamente. \par 

La optimización de la función de costo se realiza mediante métodos clásicos, como el descenso de gradientes, que ajustan los parámetros del \textit{ansatz} para minimizar la función de costo. \par 
 
El método de gradientes calcula la derivada de la función de costo respecto a los parámetros del \textit{ansatz} y ajusta estos parámetros para encontrar el mínimo de la función de costo. \par 

\section{Implementación de canales de un qubit usando VQA}
Podemos iniciar un canal cuántico en una computadora cuántica si conocemos el conjunto de compuertas necesarias que repliquen la acción del canal sobre el sistema principal $\rho$. \par 

Hemos propuesto utilizar los VQA para inicializar canales cuánticos de 1 qubit, para esto , nuestra función de costo a optimizar será la fidelidad de proceso entre la matriz de Choi teórica contra la reconstruida en una computadora cuántica. \par 
 

% }}}
\chapter{RESULTADOS PARA EL DEPOLARIZING CHANNEL DE UN QUBIT } % {{{
\section{Introducción} % {{{
\cpnote{Falta introduccion. Escribirla al final quizá de la tesis}\felnote{Pendiente: la redactaré al finalizar el cap}
% }}}
\section{Algoritmos de implementación} % {{{
Se han programado las funciones necesarias para implementar un DP mediante VQA
en una computadora cuántica. Estas funciones siguen el algoritmo presentado en
el capítulo anterior, desarrollado en el lenguaje Python con el apoyo esencial
de la librería Qiskit. A continuación, se enumeran las funciones utilizadas: 
\begin{enumerate}
    \item \texttt{Choi\_matrix\_depolarizing(p)}: genera la matriz de Choi que
corresponde al DP con probabilidad de depolarización $p$.

    \item \texttt{Cirq\_ansq(qubits, parameters, layers)}: genera un \textit{ansatz} en
un circuito cuántico de Qiskit. Toma como entradas el número de
 qubit, el listado de ángulos de rotación $\{\theta_i\}$ (indicados en
\texttt{parameters}) y el número de capas del \textit{ansatz} (indicado en
\texttt{layers}).

    \item \texttt{ProcessTomography(circuit, measurement\_indices,
preparation\_indices)}: función de Qiskit que genera los circuitos
correspondientes a la tomografía de proceso para reconstruir la matriz de Choi
en un circuito cuántico. Esta función genera $4^N3^N$ circuitos de medición
acorde a la teoría explicada en el \autoref{cap:fundamentos:teoricos}. Toma como entrada el circuito
cuántico (en  \texttt{circuit})  y el indicador correspondiente al(los)
qubit(s) donde se realizará la tomografía de proceso ( indicado en
\texttt{measurement\_indices} y \texttt{preparation\_indices}) . Tiene el
método: 
    \begin{enumerate}
	\item \texttt{Run(backend)}: método encargado de ejecutar el(los)
circuito(s) cuántico(s) en un servidor de IBM Quantum Experience. El
\texttt{backend} puede ser el simulador de Qiskit  \texttt{AerSimulator()} o
bien, una computadora cuántica en servicio. Invitamos nuevamente al lector a
ver los backends en la documentación de Qiskit \cite{Qiskit_documentation}. 
    \end{enumerate}

    \item \texttt{Process\_fidelity(channel, target)}: función de Qiskit que
mide la fidelidad de proceso entre dos matrices de Choi , (\texttt{channel}
para la matriz de choi del canal, \texttt{target} para una matriz de Choi
objetivo) \cite{Qiskit_documentation}, acorde a la ecuación \ref{ec:Choi_depolarizing}\cpnote{De nuevo referencia abstracta aca. Aparte, convendría 
aca referenciar la ecuacion exacta que necesites} \felnote{ Corregido: lo cambié a referencia de ecuación (aparecerá cuando redacte el cap 1)}

    \item \texttt{Partial\_trace(choi\_matrix,dim)}: calcula la traza parcial
sobre el sistema de una matriz de choi definida en \texttt{choi\_matrix()}.
Este cálculo se realiza dependiendo de la dimensión del sistema cuántico (por
defecto es para dos qubits) \cpnote{no estas usando italicas antes para
qubits. Creo qeu es mejor no usarlas}\felnote{Corregido: todas las instancias de qubit vienen sin itálica ahora.}.
    
    \item \texttt{Cost\_func(params)}: genera el circuito \textit{ansatz} usando
\texttt{Cirq\_ansq()}. Posteriormente utiliza \texttt{ProcessTomography()} para
ejecutar la tomografía de proceso sobre el primer qubit del circuito generado.
Finalmente calcula la función de costo usando \texttt{Process\_fidelity()}
entre la matriz de Choi reconstruida del circuito \textit{ansatz} y una matriz de Choi
objetivo. Esta función usa como entrada global la matriz de Choi objetivo
(\texttt{target} de la función \texttt{Process\_fidelity()}) y como entrada
local la lista de rotaciones $\{\theta_i\}$ (definidas en  \texttt{params}).

    \item \texttt{Minimize(fun, x0, method=None, tol)}: función de la librería
\texttt{scipy} encargada de minimización una función escalar \texttt{fun}, de
una o más variables. Esta función requiere un conjunto de parámetros iniciales
de la función \texttt{x0}. Como parte opcional se puede escoger el método de
optimización, invitamos al lector a verlos más a detalle en su respectiva
documentación \cite{scipy}. Finalmente, se puede escoger un valor de tolerancia
(indicado en \texttt{tol})  como criterio de convergencia para el método
utilizado (en \texttt{method}) y que éste se detenga.
    
\end{enumerate}
\cpnote{Va bien hasta acá. Esto te está dando la pauta de que es lo que debes expilcar en las
secciones anteriores. Toma nota!!!!}

Agrupamos estas funciones en una función general encargada de repetir el
proceso de optimización para una lista de valores de $p$. Esta función, llamada
\texttt{optimizar\_depolarizacion(p\_values)} es responsable de generar un
DataFrame de \texttt{pandas} con todos los resultados relevantes de cada
iteración. A continuación la describimos en detalle:

\noindent\rule{\textwidth}{1mm}
\texttt{Optimizar\_depolarizacion(p\_values)}: función para optimizar la
fidelidad del proceso cuántico para una lista de valores de $p$. \newline

\noindent\textbf{Entrada:} lista de valores $p$ para optimizar el \textit{ansatz}.

\noindent\textbf{Salida:} DataFrame con los valores de $p$, la fidelidad
optimizada, matriz de Choi objetivo, matriz de Choi reconstruida y los
parámetros $\{\theta_i\}$ optimizados.

\noindent\textbf{Utiliza:} \texttt{choi\_matrix\_depolarizing},
\texttt{cirq\_\textit{ansatz}}, \texttt{ProcessTomography}, \texttt{process\_fidelity},
\texttt{cost\_func}, \texttt{minimize}. \newline

Para cada valor de $p$ en \texttt{p\_values}: 
\begin{enumerate}
    \item Generar una matriz de Choi dependiente de $p$ con \texttt{Choi\_matrix\_depolarizing()}.
    \item Iniciar a  \texttt{Cost\_func()} valuado en un conjunto inicial
aleatorio de parámetros $\{\theta_i\}$. 
   \item Utilizar \texttt{Minimize()} para iterar recursivamente sobre
\texttt{Cost\_func()}, ajustando los parámetros $\{\theta_i\}$ hasta alcanzar
una convergencia definida por \texttt{tol}.
   \item Guardar los parámetros $\{ \theta_i\}$ que minimizan la función de costo. \cpnote{mas bien que minimicen la funcion de costo, no? Casi todos
los parametros iniciales van a converger} \felnote{Corregido: modifiqué la frase a .. "que minimizan la función de costo".}. 
   \item Ejecutar \texttt{ProcessTomography()} con el circuito optimizado 4
veces en el simulador \texttt{AerSimualtor()} y una vez en una computadora
cuántica. 
    \item Almacenar los parámetros optimizados $\{ \theta_i\}$, el circuito
\textit{ansatz} generado, las matrices de Choi objetvo y reconstruidas en ambos
sistemas, y sus fidelidades de proceso. 
\end{enumerate}
\vspace{-.5cm}
\noindent\rule{\textwidth}{1mm}
\cpnote{No veo el uso de las lineas gruesas. Las quitaria} \felnote{Pendiente: prefiero usar las líneas gruesas. J.A. las usó también para su tesis, me ayuda a diferenciar esta función de las demás.}
% }}}
\section{Resultados} % {{{
Para la función general, se fijaron dos hiper parámetros de 
\texttt{Cirq\_ansq()}: \texttt{layers} y  qubit. El número de capas se
estableció en 1, ya que no se observó una mejora significativa en los tiempos
de optimización, ni en la minimización de la función de costo al aumentar este
parámetro, esto lo podemos ver en la figura \ref{fig:comparacion_capas} \cpnote{Tocaría mostrar una gráfica donde se demuestre esa afirmación.}\felnote{Corregido: la agregué en la fig. \ref{fig:comparacion_capas}.}. Por otro lado, se utilizaron 4 qubits en el \textit{ansatz}, donde una mitad funcionó como \textit{ancilla} y la otra para el sistema, siguiendo el diseño presentado en el \textit{ansatz} \ref{fig:ansatz_dp}. Esto se decidió porque al utilizar únicamente dos  qubits no se alcanzó la convergencia en la función de costo. \cpnote{no porqué pero cuando tienes qubit a
veces no separas el espacio entre la palabra anteiror y qubit. Creo que es
porque cambiaste automaticamente. } \felnote{Corregido: aparece qubit sin notaciones raras en todas las instancias.}

\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.70 \linewidth]{imagenes/comparacion_capas.png}
    \caption{Comparación de el proceso de optimización del ansatz utilizado para el DP a diferentes capas. En azul vemos el resultado para una capa, amarillo para dos y verde para tres. Estos resultados fueron ejecutados para un valor de $p=0.125$. \textbf{Fuente}: elaboración propia. \felnote{Duda: está bien en escala logarítmica? Ahí se ve mejor la diferencia, pero puedo hacerlo también en escala normal}}
    \label{fig:comparacion_capas}
\end{figure}


Para la función \texttt{Minimize}() se fijaron dos hiper parámetros : \texttt{method} y \texttt{tol}. Se utilizó el método \texttt{COBYLLA}, que realiza la minimización mediante aproximaciones lineales, mientras que la tolerancia se ajustó a $1\times 10^{-15}$. Se tomaron estos hiperparámetros porque con ellos alcanzamos consistentemente la minimización de la función de costo sin estresar de forma inecesaria el equipo de trabajo. \cpnote{frase
con una redaccion muy rara. No se entiende, quizá incluir otro gráfico? quizá 
ya es demasiado... } \felnote{Corregido: modifiqué la redacción del parrafo (linea 254 a 258) .  Pendiente: por el lado del gráfico también pienso que sería mucho considerando que ya esta el de comparación de capas.}.


Es importante mencionar las limitaciones al usar las computadoras cuánticas de
IBM, donde el tiempo de uso está limitado a 10 minutos mensuales\footnote{Este
es el tiempo de uso disponible en el plan gratuito de IBM.}. Vimos que el
tiempo de ejecución de una tomografía de proceso para un canal de un  qubit
\cpnote{revisa todas las instancias de qubit y dejalo sin italicas por favor} \felnote{Corregido: qubit aparece ahora sin itálica en todas las instancias.}
requiere 12 circuitos, que lleva un tiempo de ejecución promedio de $16s$. Por
esta razón decidimos optimizar el \textit{ansatz} en el simulador cuántico y
posteriormente, ejecutar el circuito optimizado en una computadora cuántica.
Además, el simulador no tiene restricciones de tiempo, por ello ejecutamos el
\textit{ansatz} optimizado 4 veces para cada valor de $p$ en el simulador de
\texttt{AerSimualtor()}.

La función general se ejecutó para un listado de 38 valores distintos de $p$ en
\texttt{p\_values}, ajustándose al tiempo mensual disponible en IBM, con un
margen de error de una tomografía mensual. Cada circuito se ejecutó para un
número de 4000 mediciones por circuito. \cpnote{demasiados anglisismos. Solo usalos si la 
traduccion es rara. aca puedes aclarar la situacion en español} \felnote{Corregido: solo uso anglisismo si me refiero a alguna función del código. Modifiqué también la palabra 'shots' a 'mediciones por circuito' (línea 276) .},
para la computadora cuántica como
en el simulador. No incluimos todos los resultados detallados en esta sección
para evitar sobrecargar la discusión\footnote{Se puede acceder al dataframe
final, así como al código de este proyecto el github:
\href{https://github.com/felipechoy1/EPS/tree/main/Código\%20y\%20Resultados}{https://github.com/felipechoy1/EPS/tree/main/Código\%20y\%20Resultados}}.

Los resultados correspondientes a las fidelidades alcanzadas en la computadora
cuántica como en el simulador son presentadas en la figura
\ref{fig:comparacion_fidelidad}. Aquí obtenemos fidelidades en la computadora
cuántica en el rango de $0.553\leq F_{proc} \leq 0.974$. Por otro lado, para el
simulador, el promedio de las fidelidades en las 4 ejecuciones está en el rango
de $0.762\leq F_{proc} \leq 0.993$. Finalmente, al observar la desviación
estándar en los cálculos del simulador, se obtienen valores en el rango de
$0.001\leq \sigma_{F_{proc}} \leq 0.027$. Esta comparación se presenta en la
tabla \ref{tab:comparacion_fidelidades}.



\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.7\linewidth]{imagenes/comparacion fidelidad.png}
    \caption{Comparación de fidelidades de proceso luego de ejecutar el \textit{ansatz}
optimizado. En azul se encuentra la fidelidad de la matriz de Choi reconstruida
en el simulador cuántico \texttt{AerSimualtor()}. Por otro lado en azul,
corresponde a la ejecución en la computadora cuántica \texttt{ibm-kyoto}.
\textbf{Fuente}: elaboración propia. }
    \label{fig:comparacion_fidelidad}
    \end{figure}
    

\begin{table}[htbp]
\centering 
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
\textbf{Backend} & \textbf{Mediana} & \textbf{Mínimo} & \textbf{Máximo} & \textbf{p(max)} & \textbf{p(min)} & \textbf{Desv. Estándar} \\ \hline
Aer Simulator & 0.9618  & 0.7620  & 0.9925 & 0.975 & 0.725 & 0.0418 \\ \hline
ibm-kyoto     & 0.8916 & 0.5533 & 0.9738 & 0.825 & 0.125 & 0.0899  \\ \hline
\end{tabular}
}
\caption{Comparación de fidelidad de proceso entre las matrices de Choi
reconstruidas del \textit{ansatz} optimizado. Los resultados de la computadora cuántica
fueron tomados en \texttt{ibm-kyoto}, mientras que en el simulador fueron en
\texttt{AerSimualtor()} de Qiskit. \textbf{Fuente:} elaboración propia.}
\label{tab:comparacion_fidelidades}
\end{table}

Como parte de la evaluación de completa positividad (CP)  de las matrices
reconstruidas, es importante analizar los autovalores de la matriz de Choi
correspondiente al DP. Sabemos que su matriz de Choi esta
dada por la ecuación \ref{ec:Choi_depolarizing} \felnote{Aquí todavía no
aparece porque la declararemos en el capítulo 1}. Por lo tanto, sus autovalores
se calculan resolviendo:
\begin{equation}
\det(\Lambda_\mathcal{E} - \lambda I) = 0,
\end{equation}
donde $\Lambda_\mathcal{E}$ es la matriz de Choi e $I$ es la matriz identidad
de dimensiones $4 \times 4$. Para resolver esta ecuación, restamos $\lambda$ de
los elementos diagonales de $\Lambda_\mathcal{E}$:
\begin{equation}
\Lambda_\mathcal{E} - \lambda I = \begin{pmatrix}
1 - \frac{p}{2} - \lambda & 0 & 0 & 1 - p \\
0 & \frac{p}{2} - \lambda & 0 & 0 \\
0 & 0 & \frac{p}{2} - \lambda & 0 \\
1 - p & 0 & 0 & 1 - \frac{p}{2} - \lambda
\end{pmatrix}.
\end{equation}
Al encontrar la determinante de la matriz:
\begin{equation}
\left( \frac{p}{2} - \lambda \right)^2  \left[ \left( 1 - \frac{p}{2} - \lambda \right)^2 - (1 - p)^2 \right] = 0.
\end{equation}
Esto se puede factorizar como:
\begin{equation}
\left( \frac{p}{2} - \lambda \right)^2 \left( \lambda - \frac{p}{2} \right) \left( \lambda - \left( 2 - \frac{3p}{2} \right) \right) = 0.
\end{equation}
Por lo tanto, los autovalores de $\Lambda_{\mathcal{E}}$ son:
\begin{align}
\lambda_1 &=\lambda_2=\lambda_3 = \frac{p}{2} \quad \\
\lambda_4 &= 2 - \frac{3p}{2} .
\end{align}
Comparamos los autovalores de nuestros resultados en la figura
\ref{fig:comparacion_autovalores} para cada valor de $p$. Notamos que todos los
autovalores para todos los valores de $p$ cumplen con ser mayores o iguales a
0. Por lo tanto, los canales reconstruidos cumplen con ser CP.  Por otro
lado, al analizar la condición de preservación de la traza (TP) notamos que
ninguna de las matrices de Choi reconstruidas en ninguno de los sistemas cumple
con preservar la traza. Esto lo verificamos trazando parcialmente las matrices
de Choi con \texttt{partial\_trace()}, cuyo resultado no coincide con la matriz
identidad $I$. \cpnote{Aca si puede haber un problema más serio. Lo platicamos.} \felnote{Pendiente: Noté que se quedan bastante cerca a los valores de la identidad, pero siguen difiriendo. (ver imagen comparaciones\_identidad\_reconstruida.png en la carpeta de imagenes del proyecto) }
\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.90 \linewidth]{imagenes/eigenvalores_comparacion.png}
    \caption{Comparación de autovalores correspondientes a la matriz de Choi reconstruidas. En azul se puede ver el autovalor esperado a lo largo de $p$, en verde vemos el promedio de los valores de las matrices de Choi reconstruidas  en el simulador cuántico \texttt{AerSimualtor()}. Finalmente vemos en rojo los autovalores correspondientes a las matrices de Choi reconstruidas en la computadora cuántica \texttt{ibm-kyoto}. \textbf{Fuente}: elaboración propia. }
    \label{fig:comparacion_autovalores}
\end{figure}
% }}}
\section{Discusión de Resultados} % {{{
En esta sección discutiremos sobre las diferencias encontradas entre las
fidelidades y autovalores calculados en el simulador y la computadora cuántica.
Vemos que estas diferencias se deben en gran parte a que la optimización fue realizada en el simulador cuántico, el cual esta configurado en un entorno ideal. \cpnote{A ver si lo justificas mas adelante. Se me hace una frase osada} \felnote{Corregido: lo modifiqué porque realmente optimicé con el simulador (línea 312 a 314) . De igual forma, aquí abajo deje comentada la frase anterior}
% Vemos que estas diferencias se deben en gran parte a los errores inherentes al
% hardware cuántico real, como la decoherencia, errores en las compuertas
% cuánticas y limitaciones en la precisión de las mediciones. 


La figura \ref{fig:comparacion_fidelidad} así como la tabla
\ref{tab:comparacion_fidelidades} muestran que el simulador cuántico produce
resultados con fidelidades consistentemente cercanas a 1 a lo largo de todo el
rango de $p$. En contraste, la computadora cuántica presenta una mayor
variabilidad en sus resultados. Para analizar esta diferencia, realizamos una
regresión lineal de la fidelidad en función de $p$ tanto para la computadora
cuántica como para el simulador, como se muestra en la figura
\ref{fig:comparacion_regresiones}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.95\linewidth]{imagenes/Comparacion_regresiones.png}
    \caption{Comparación de regresiones lineales entre los resultados de la fidelidad de proceso entre la matriz de Choi esperada , la computadora cuántica \texttt{ibm\_kyoto} y el simualdor cuántico \texttt{AerSimualtor()} respectivamente. \textbf{Fuente:} elaboración propia.}
    \label{fig:comparacion_regresiones}
\end{figure}

En el caso de la computadora cuántica, la ecuación de la regresión lineal es:
\begin{equation}
    F_{proc\_qc}(p) = 0.2707 \cdot p + 0.7376,
\end{equation}
con un coeficiente de determinación $R^2 = 0.7055$ y un valor de Chi-cuadrado
de $\chi^2 = 0.1085$.  Esto indica que la fidelidad tiende a aumentar con la probabilidad de despolarización $p$, pero el ajuste no es perfecto. Los valores de $R^2$ y $\chi^2$ sugieren que la relación no es estrictamente lineal y que podría haber otros factores influyendo en los resultados en la computadora cuántica. \cpnote{no, tu propusiste un crecimiento lineal. 
y la verdad no da tan bien. mejorra la interpretacion. quizá es mejor si discutimos acerca 
de estas graficas} \felnote{Corregido:  es cierto, no necesariamente es lineal y no es una correlación muy fuerte (línea 326 a 328). También quisiera que hablaramos sobre las gráficas}. 

Este comportamiento puede explicarse porque, al aumentar $p$ en el DP, los estados se vuelven más mixtos y menos afectados por errores específicos del hardware cuántico. En sistemas como \texttt{ibm\_kyoto}, una alta despolarización puede reducir el impacto de errores de las compuertas cuánticas y la decoherencia, ya que el estado menos puro es menos sensible a estos fallos. Entonces, la fidelidad mejora con  $p$ porque el DP atenúa algunos errores del sistema, no porque el hardware mejore su rendimiento. \cpnote{Interpretación chafa}\felnote{Pendiente: reescribí este parrafo, quisiera saber tu opinión. ( 334 a 341). }


Por otro lado, observamos que el simulador \texttt{AerSimulator()} tiene una ecuación de la recta:
\begin{equation}
    F_{proc\_sim}(p) = 0.0371 \cdot p + 0.9346,
\end{equation}
con un coeficiente de determinación $R^2 = 0.0612$ y un valor de Chi-cuadrado
de $\chi^2 = 0.0633$. El bajo valor de $R^2$ en el simulador sugiere que, a
diferencia de la computadora cuántica, la fidelidad en el simulador no parece
depender significativamente de $p$\cpnote{esto me gusta mas}. Además, la pendiente de la recta es
pequeña, lo que indica que la fidelidad en el simulador es prácticamente
constante a lo largo del rango de $p$. \cpnote{estaría bueno comentar el
outlier que esta bien raro} \felnote{Pendiente: lo comento adelante en el rango de 0.6 a 0.75. En la línea 353.}

Analizamos la variabilidad de fidelidad en ambos casos, como se muestra en la
figura \ref{fig:comparacion_desviaciones}. En el simulador cuántico, no se
observa una tendencia clara en la desviación estándar de la fidelidad a lo
largo de $p$, excepto en el intervalo $0.6 \le p \leq 0.75$, que parece ser una
anomalía en los datos. Por otro lado, la computadora cuántica muestra una
reducción en la desviación estándar de la fidelidad a medida que aumenta $p$,
lo que confirma nuestra suposición basada en la regresión lineal. Finalmente,
en ambos casos, observamos que para valores de $p>0.75$, la desviación estándar
disminuye significativamente.\cpnote{Creo que hay varios estudios que sugieren que 
el comportamiento de la computadora cuántica de la IBM no es estacionario. 
Sería bueno citarlos. Hablemos también} \felnote{Pendiente: estuve investigando y me encontré con este paper: https://arxiv.org/pdf/2302.10881 . Aquí mencionan como los errores fuera de  resonancia pueden causar comporatmientos no estacionarios. Pero si quisiera que lo vieramos también.}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.95\linewidth]{imagenes/Comparacion_desviaciones.png}
    \caption{Comparación de desviación estándar entre los resultados de la fidelidad de proceso entre la matriz de Choi esperada , la computadora cuántica \texttt{ibm\_kyoto} (color naranja) y el simualdor cuántico (color azul) \texttt{AerSimualtor()}. La desviación estándar se calcula sobre los valores de fidelidad en el intervalo de $p$. \textbf{Fuente:} elaboración propia.}
    \label{fig:comparacion_desviaciones}
\end{figure}


Al analizar los cuatro autovalores presentados en la figura
\ref{fig:comparacion_autovalores}, notamos que tanto en el simulador como en la
computadora cuántica, los autovalores $\lambda_1,\lambda_2,\lambda_3$ no son
iguales entre sí. Además, en todos los casos, la computadora cuántica se desvía
más de los resultados esperados en comparación con el simulador.
Específicamente, observamos que la computadora cuántica comienza con valores
más altos para $\lambda_1,\lambda_2,\lambda_3$, y también con valores más bajos
para $\lambda_4$ en comparación con el simulador.  Estos primeros tres
autovalores están relacionados con la probabilidad de que el canal mantenga el
estado cuántico original, mientras que el cuarto autovalor corresponde a la
probabilidad de que el estado cuántico se vuelva completamente mixto. Por lo
tanto, estas observaciones sugieren que la computadora cuántica introduce más
ruido desde etapas tempranas, que se refleja en una tendencia menos pronunciada
en comparación con el simulador. Esta interpretación es coherente con los
resultados obtenidos en la regresión lineal, donde el intercepto de la
fidelidad en la computadora cuántica ($0.7376$) es menor que en el simulador,
que muestra fidelidades iniciales más altas y con menor variabilidad
($0.9346$).

\cpnote{Me falta corregir este parrafo pues no entiendo la figura} \felnote{Corregido: reescalé la figura \ref{fig:comparacion_choi}, y le cambié el caption.}
En la figura \ref{fig:comparacion_choi}, observamos que las matrices de Choi
generadas por la computadora cuántica presentan mayor coherencia en las
entradas no diagonales. Esto también nos muestra que la computadora cuántica
introduce ruido desde un inicio. Notemos que al incrementar $p$, introducimos
más ruido a la interacción, que hace que nuestra fidelidad mejore con la
computadora cuántica. Por otro lado , las matrices obtenidas del simulador son
más consistentes con los vlores teóricos, con valores casi nulos en las
posiciones no diagonales, reflejando mayor fidelidad en la simulación del canal
a lo largo de $p$.

\begin{figure}[h!]
    \centering
    % Subfigura para p = 0.1
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{imagenes/comp_choi_p0.1.png}
        \caption{Comparación de matrices de Choi para p = 0.1}
        \label{fig:choi_p0.1}
    \end{subfigure}
    \vspace{1em} % Espacio vertical entre subfiguras
    
   
    % Subfigura para p = 0.5
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{imagenes/comp_choi_p0.5.png}
        \caption{Comparación de matrices de Choi para p = 0.5}
        \label{fig:choi_p0.5}
    \end{subfigure}
    \vspace{1em}
    
    % Subfigura para p = 0.9
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{imagenes/comp_choi_p0.9.png}
        \caption{Comparación de matrices de Choi para p = 0.9}
        \label{fig:choi_p0.9}
    \end{subfigure}
    
    \caption[Comparación de matrices de Choi objetivo y reconstruidas]{\cpnote{figura chafa. No se puede leer los números y además no entiendo qué son las filas, las columnas, en fin. Hablemos de esta figura} \felnote{Corregido: la segmenté en partes para que se vean mejor y cambie el caption.}
    Comparación de matrices de Choi objetivo y matrices de Choi reconstruidas en el simulador cuántico \texttt{AerSimulator()}, como en la computadora cuántica \texttt{ibm\_kyoto}. Los valores se presentan para disntintas probabilidades de despolarización $p$ del DP. Cada valor representa una componente real de la matriz de Choi. \textbf{Fuente:} elaboración propia.}
    \label{fig:comparacion_choi}
\end{figure}

% }}}
% }}}
\chapter{CONCLUSIONES} % {{{
\section{Conclusiones}
\section{Trabajo a Futuro}
\subsection{Implementación de VQA para 2 qubits}
% }}}
\appendix
% Notas sueltas {{{

% En la teoría cuántica, un sistema cuántico abierto es aquel que no está aislado, sino que interactúa continuamente con su entorno. Este tipo de sistemas son fundamentales para entender muchos fenómenos cuánticos en la práctica, ya que cualquier sistema cuántico real interactúa con su entorno. A diferencia de los sistemas cuánticos cerrados, que se consideran completamente aislados y evolucionan de manera unitaria según la ecuación de Schrödinger, los sistemas cuánticos abiertos pueden sufrir pérdidas de coherencia cuántica debido a estas interacciones. En la sección 3.1 exploraremos este tipo de sistemas por medio de canales cuánticos, con énfasis en su representación con la matriz de Choi. En la sección 3.2 mencionaremos la tomografía y fidelidad de proceso cuántico, ya que son importantes para la reconstrucción de canales cuánticos en computadoras cuánticas


% % Pendiente de redactar
% Los Algoritmos Variacionales Cuánticos (VQA) representan una estrategia innovadora en el campo de la computación cuántica para resolver problemas complejos. A través de un esquema híbrido que aprovecha tanto recursos cuánticos como clásicos, los VQA buscan optimizar un conjunto de parámetros en un circuito cuántico parametrizado. Estos algoritmos son fundamentales en tareas donde la solución se codifica dentro de una función de costo o pérdida, la cual es minimizada a través del ajuste variacional de parámetros dentro del circuito. \cite{VQA}

% El circuito cuántico parametrizado, o \textit{\textit}, es diseñado para ser versátil y adaptarse a la naturaleza del problema y las características del hardware cuántico disponible. Los \textit{ansatz} más efectivos, como el Hardware Efficient \textit{ansatz} (HEA), son aquellos que equilibran la expresividad del circuito y la eficiencia en términos de recursos y operaciones cuánticas requeridas. \cite{VQA}

% El proceso de optimización en VQAs se articula en tres fases principales:
% \begin{enumerate}
%     \item \textbf{Inicialización:} Se comienza con la preparación de un estado cuántico de referencia, sobre el cual se aplicarán las operaciones del \textit{\textit{ansatz}}.
%     \item \textbf{Aplicación del \textit{ansatz}:} Se utiliza el \textit{\textit{ansatz}} para transformar el estado inicial en un estado final que depende de los parámetros variacionales. Este paso es crítico y requiere una cuidadosa selección y configuración de las puertas cuánticas para navegar el espacio de Hilbert eficazmente.
%     \item \textbf{Evaluación y Optimización:} Se evalúa la función de costo mediante mediciones cuánticas y se emplea un optimizador clásico para ajustar los parámetros en busca de un mínimo, completando así el bucle cuántico-clásico.
% \end{enumerate}
% \subsubsection{Ejemplo: Inicialización de estados mixtos en computadoras cuánticas}
% Faltante de redactar




% \section{Aplicación de VQA para la simulación de Canales Cuánticos}
% Faltante de Redactar





% }}}
\bibliographystyle{abbrv}
\bibliography{references}   % Bibliografía
\end{document}
